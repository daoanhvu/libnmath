[0][0]0		[1][0]4		[2][0]8		[3][0]12
[0][1]1		[1][1]5		[2][1]9		[3][1]13
[0][2]2		[1][2]6		[2][2]10	[3][2]14
[0][3]3		[1][3]7		[2][3]11	[3][3]15

//column major
//http://rodolphe-vaillant.fr/?e=7
bool gluInvertMatrix(const double m[16], double invOut[16]) {
    double inv[16], det;
    int i;

    inv[0][0] = m[1][1] * m[2][2] * m[3][3] - m[1][1] * m[2][3] * m[3][2] - 
				m[2][1] * m[1][2] * m[3][3] + m[2][1] * m[1][3] * m[3][2] +
				m[3][1] * m[1][2] * m[2][3] - m[3][1] * m[1][3] * m[2][2];

    inv[1][0] = -m[1][0] * m[2][2] * m[3][3] + m[1][0] * m[2][3] * m[3][2] + 
				 m[2][0] * m[1][2] * m[3][3] - m[2][0] * m[1][3] * m[3][2] - 
				 m[3][0] * m[1][2] * m[2][3] + m[3][0] * m[1][3] * m[2][2];

    inv[2][0] = m[1][0] * m[2][1] * m[3][3] - m[1][0] * m[2][3] * m[3][1] -
				m[2][0] * m[1][1] * m[3][3] + m[2][0] * m[1][3] * m[3][1] +
				m[3][0] * m[1][1] * m[2][3] - m[3][0] * m[1][3] * m[2][1];

    inv[3][0] = -m[1][0] * m[2][1] * m[3][2] + m[1][0] * m[2][2] * m[3][1] +
				 m[2][0] * m[1][1] * m[3][2] - m[2][0] * m[1][2] * m[3][1] - 
				 m[3][0] * m[1][1] * m[2][2] + m[3][0] * m[1][2] * m[2][1];

    inv[0][1] = -m[0][1] * m[2][2] * m[3][3] + m[0][1] * m[2][3] * m[3][2] + 
				 m[2][1] * m[0][2] * m[3][3] - m[2][1] * m[0][3] * m[3][2] - 
				 m[3][1] * m[0][2] * m[2][3] + m[3][1] * m[0][3] * m[2][2];

    inv[1][1] = m[0][0] * m[2][2] * m[3][3] - m[0][0] * m[2][3] * m[3][2] - 
				m[2][0] * m[0][2] * m[3][3] + m[2][0] * m[0][3] * m[3][2] + 
				m[3][0] * m[0][2] * m[2][3] - m[3][0] * m[0][3] * m[2][2];

    inv[2][1] = -m[0][0] * m[2][1] * m[3][3] + m[0][0] * m[2][3] * m[3][1] + 
				 m[2][0] * m[0][1] * m[3][3] - m[2][0] * m[0][3] * m[3][1] - 
				 m[3][0] * m[0][1] * m[2][3] + m[3][0] * m[0][3] * m[2][1];

    inv[3][1] = m[0][0] * m[2][1] * m[3][2] - m[0][0] * m[2][2] * m[3][1] - 
				m[2][0] * m[0][1] * m[3][2] + m[2][0] * m[0][2] * m[3][1] + 
				m[3][0] * m[0][1] * m[2][2] - m[3][0] * m[0][2] * m[2][1];

    inv[0][2] = m[0][1]  * m[1][2] * m[3][3] - m[0][1]  * m[1][3] * m[3][2] - 
             m[1][1]  * m[0][2] * m[3][3] + m[1][1]  * m[0][3] * m[3][2] + 
             m[3][1] * m[0][2] * m[1][3] - m[3][1] * m[0][3] * m[6];

    inv[6] = -m[0][0] * m[1][2] * m[3][3] + m[0][0] * m[1][3] * m[3][2] + 
              m[1][0] * m[0][2] * m[3][3] - m[1][0] * m[0][3] * m[3][2] - 
              m[3][0] * m[0][2] * m[1][3] + m[3][0] * m[0][3] * m[1][2];

    inv[10] = m[0][0]  * m[1][1] * m[3][3] - m[0][0]  * m[1][3] * m[3][1] - 
              m[1][0]  * m[0][1] * m[3][3] + m[1][0]  * m[0][3] * m[3][1] + 
              m[3][0] * m[0][1] * m[1][3] - m[3][0] * m[0][3] * m[1][1];

    inv[14] = -m[0][0]  * m[1][1] * m[3][2] + 
               m[0][0]  * m[1][2] * m[3][1] + 
               m[1][0]  * m[0][1] * m[3][2] - 
               m[1][0]  * m[0][2] * m[3][1] - 
               m[3][0] * m[0][1] * m[1][2] + 
               m[3][0] * m[0][2] * m[1][1];

    inv[3] = -m[0][1] * m[1][2] * m[2][3] + 
              m[0][1] * m[1][3] * m[2][2] + 
              m[1][1] * m[0][2] * m[2][3] - 
              m[1][1] * m[0][3] * m[2][2] - 
              m[2][1] * m[0][2] * m[1][3] + 
              m[2][1] * m[0][3] * m[1][2];

    inv[7] = m[0][0] * m[1][2] * m[2][3] - 
             m[0][0] * m[1][3] * m[2][2] - 
             m[1][0] * m[0][2] * m[2][3] + 
             m[1][0] * m[0][3] * m[2][2] + 
             m[2][0] * m[0][2] * m[1][3] - 
             m[2][0] * m[0][3] * m[1][2];

    inv[11] = -m[0][0] * m[1][1] * m[2][3] + 
               m[0][0] * m[1][3] * m[2][1] + 
               m[1][0] * m[0][1] * m[2][3] - 
               m[1][0] * m[0][3] * m[2][1] - 
               m[2][0] * m[0][1] * m[1][3] + 
               m[2][0] * m[0][3] * m[1][1];

    inv[15] = m[0][0] * m[1][1] * m[2][2] - 
              m[0][0] * m[1][2] * m[2][1] - 
              m[1][0] * m[0][1] * m[2][2] + 
              m[1][0] * m[0][2] * m[2][1] + 
              m[2][0] * m[0][1] * m[1][2] - 
              m[2][0] * m[0][2] * m[1][1];

    det = m[0][0] * inv[0] + m[0][1] * inv[4] + m[0][2] * inv[8] + m[0][3] * inv[12];

    if (det == 0)
        return false;

    det = 1.0 / det;

    for (i = 0; i < 16; i++)
        invOut[i] = inv[i] * det;

    return true;
}